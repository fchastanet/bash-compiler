@startuml
legend
<u><b>Legend</b></u>
Render Aggregations: true
Render Fields: true
Render Methods: true
Private Aggregations: true
end legend
namespace binary {
    class CodeCompilerContext << (S,Aquamarine) >> {
        + BinaryModelContext *model.BinaryModelContext
        + TemplateContext *render.Context
        + CodeGenerator *generator.CodeGeneratorInterface
        + CodeCompiler *compiler.CodeCompilerInterface

        + Compile(targetDir string, binaryModelFilePath string, binaryModelBaseName string, referenceDir string, keepIntermediateFiles bool) (string, error)

    }
    interface CompilerInterface  {
        + Compile(targetDir string, binaryModelFilePath string, binaryModelBaseName string, referenceDir string, keepIntermediateFiles bool) (string, error)

    }
}

"binary.CompilerInterface" <|-- "implements""binary.CodeCompilerContext"

"binary.CodeCompilerContext""uses" o-- "compiler.CodeCompilerInterface"
"binary.CodeCompilerContext""uses" o-- "generator.CodeGeneratorInterface"
"binary.CodeCompilerContext""uses" o-- "model.BinaryModelContext"
"binary.CodeCompilerContext""uses" o-- "render.Context"

namespace compiler {
    interface AnnotationProcessorInterface  {
        + Init() error
        + ParseFunction(functionStruct *functionInfoStruct) error
        + Process() error
        + PostProcess(code string) (string, error)

    }
    interface CodeCompilerInterface  {
        + Init() error
        + Compile(code string) (string, error)

    }
    class compileContext << (S,Aquamarine) >> {
        - templateContext *render.Context
        - functionsMap <font color=blue>map</font>[string]functionInfoStruct
        - ignoreFunctionsRegexp []*regexp.Regexp
        - config model.CompilerConfig
        - annotationProcessors []*AnnotationProcessorInterface

        - renderEachFunctionAsTemplate() error
        - isNonFrameworkFunction(functionName string) bool
        - nonFrameworkFunctionRegexpCompile()
        - generateFunctionCode() (string, error)
        - retrieveAllFunctionsContent() (bool, error)
        - retrieveEachFunctionPath() (bool, error)
        - extractUniqueFrameworkFunctions(code string) bool
        - findFileInSrcDirs(relativeFilePath string) (string, string, bool)

        + Init() error
        + Compile(code string) (string, error)

    }
    class compiler.InsertPosition << (T, #FF7700) >>  {
    }
    class duplicatedAsNameError << (S,Aquamarine) >> {
        - lineNumber int
        - asName string
        - resource string

        + Error() string

    }
    class embedAnnotationProcessor << (S,Aquamarine) >> {
        - context *compileContext
        - embedFileTemplateName string
        - embedDirTemplateName string
        - embedMap <font color=blue>map</font>[string]string

        - renderFile(asName string, resource string, fileMode os.FileMode) (string, error)
        - renderDir(asName string, resource string) (string, error)
        - renderTemplate(data <font color=blue>map</font>[string]string, templateName string) (string, error)

        + Init() error
        + ParseFunction(_ *functionInfoStruct) error
        + Process() error
        + PostProcess(code string) (string, error)
        + RenderResource(asName string, resource string, lineNumber int) (string, error)

    }
    class functionInfoStruct << (S,Aquamarine) >> {
        + FunctionName string
        + SrcFile string
        + Inserted bool
        + InsertPosition InsertPosition
        + SourceCode string
        + SourceCodeLoaded bool
        + SourceCodeAsTemplate bool
        + AnnotationMap <font color=blue>map</font>[string]<font color=blue>interface</font>{}

        - getRequireAnnotation() (*requireAnnotation, error)

    }
    class requireAnnotation << (S,Aquamarine) >> {
        - requiredFunctions []string
        - isRequired bool
        - isComputed bool

    }
    class requireAnnotationProcessor << (S,Aquamarine) >> {
        - context *compileContext
        - checkRequirementsTemplateName string
        - requireTemplateName string

        - addRequireCodeToEachRequiredFunctions(functionStruct *functionInfoStruct) error
        - addCheckRequirementsCodeIfNeeded(functionStruct *functionInfoStruct) error
        - addRequireCode(functionStruct *functionInfoStruct) error
        - addCheckRequirementsCode(functionStruct *functionInfoStruct, requires []string) error

        + Init() error
        + ParseFunction(functionStruct *functionInfoStruct) error
        + Process() error
        + PostProcess(code string) (string, error)

    }
    class unsupportedEmbeddedResourceError << (S,Aquamarine) >> {
        - asName string
        - resource string
        - lineNumber int
        - innerError error

        + Error() string

    }
}

"compiler.CodeCompilerInterface" <|-- "implements""compiler.compileContext"
"compiler.AnnotationProcessorInterface" <|-- "implements""compiler.embedAnnotationProcessor"
"compiler.AnnotationProcessorInterface" <|-- "implements""compiler.requireAnnotationProcessor"

"compiler.compileContext""uses" o-- "compiler.AnnotationProcessorInterface"
"compiler.compileContext""uses" o-- "compiler.functionInfoStruct"
"compiler.compileContext""uses" o-- "model.CompilerConfig"
"compiler.compileContext""uses" o-- "regexp.Regexp"
"compiler.compileContext""uses" o-- "render.Context"
"compiler.embedAnnotationProcessor""uses" o-- "compiler.compileContext"
"compiler.functionInfoStruct""uses" o-- "compiler.InsertPosition"
"compiler.requireAnnotationProcessor""uses" o-- "compiler.compileContext"

namespace generator {
    class CodeGeneratorContext << (S,Aquamarine) >> {
        - yamlFilePath string
        - targetDir string
        - binaryModelBaseName string
        - keepIntermediateFiles bool
        - templateContext *render.Context

        + GenerateCode() (string, error)

    }
    interface CodeGeneratorInterface  {
        + GenerateCode() (string, error)

    }
}

"generator.CodeGeneratorInterface" <|-- "implements""generator.CodeGeneratorContext"

"generator.CodeGeneratorContext""uses" o-- "render.Context"

namespace main {
    class Directory << (S,Aquamarine) >> {
        + Validate() error

    }
    class VersionFlag << (S,Aquamarine) >> {
        + Decode(_ *kong.DecodeContext) error
        + IsBool() bool
        + BeforeApply(app *kong.Kong, vars kong.Vars) error

    }
    class YamlFile << (S,Aquamarine) >> {
        + Validate() error

    }
    class cli << (S,Aquamarine) >> {
        + YamlFile YamlFile
        + TargetDir Directory
        + Version VersionFlag
        + KeepIntermediateFiles bool
        + Debug bool
        + LogLevel int
        + CompilerRootDir Directory

    }
    class main.Directory << (T, #FF7700) >>  {
    }
    class main.VersionFlag << (T, #FF7700) >>  {
    }
    class main.YamlFile << (T, #FF7700) >>  {
    }
}


"main.cli""uses" o-- "main.Directory"
"main.cli""uses" o-- "main.VersionFlag"
"main.cli""uses" o-- "main.YamlFile"

namespace model {
    class BinaryModel << (S,Aquamarine) >> {
        + CompilerConfig CompilerConfig
        + Vars Dictionary
        + BinData <font color=blue>interface</font>{}

    }
    class BinaryModelContext << (S,Aquamarine) >> {
        + BinaryModel *BinaryModel
        + TargetDir string
        + BinaryModelFilePath string
        + BinaryModelBaseName string
        + ReferenceDir string
        + KeepIntermediateFiles bool

        - setEnvVars()
        - expandVars()

        + LoadBinaryModel() error

    }
    interface BinaryModelInterface  {
        + LoadBinaryModel() error

    }
    class CompilerConfig << (S,Aquamarine) >> {
        + DynamicConfig Dictionary
        + TargetFile string
        + RelativeRootDirBasedOnTargetDir string
        + CommandDefinitionFiles []string
        + TemplateFile string
        + TemplateDirs []string
        + FunctionsIgnoreRegexpList []string
        + SrcDirs []string
        + SrcDirsExpanded []string

    }
    class Dictionary << (S,Aquamarine) >> {
        + GetStringValue(key string) (string, error)
        + GetStringList(key string) ([]string, error)

    }
    class model.Dictionary << (T, #FF7700) >>  {
    }
}

"model.BinaryModelInterface" <|-- "implements""model.BinaryModelContext"

"model.BinaryModel""uses" o-- "model.CompilerConfig"
"model.BinaryModel""uses" o-- "model.Dictionary"
"model.BinaryModelContext""uses" o-- "model.BinaryModel"
"model.CompilerConfig""uses" o-- "model.Dictionary"

namespace render {
    class Context << (S,Aquamarine) >> {
        + Template *template.Template
        + TemplateName string
        + RootData <font color=blue>interface</font>{}
        + Data <font color=blue>interface</font>{}

        + RenderFromTemplateName() (string, error)
        + Render(template string) (string, error)

    }
}


"render.Context""uses" o-- "template.Template"

"__builtin__.int8" #.. "alias of""compiler.InsertPosition"
"__builtin__.string" #.. "alias of""main.Directory"
"__builtin__.string" #.. "alias of""main.VersionFlag"
"__builtin__.string" #.. "alias of""main.YamlFile"
"model.<font color=blue>map</font>[string]<font color=blue>interface</font>{}" #.. "alias of""model.Dictionary"
@enduml
